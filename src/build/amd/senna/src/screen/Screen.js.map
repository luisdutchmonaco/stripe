{"version":3,"sources":["Screen.js"],"names":["Screen","id","makeId_","metas","title","console","log","path","state","surfaces","Object","keys","forEach","sId","activeChild","runScriptsInElement","resolve","transitions","surface","deferred","show","push","all","isImplementedBy","object"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAOMA,M;;;AAEL;;;;;;;AAOA,oBAAc;AAAA;;AAAA;;AAGb;;;;;AAKA,SAAKC,EAAL,GAAU,MAAKC,OAAL,CAAa,oBAAb,CAAV;;AAEA;;;;AAIA,SAAKC,KAAL,GAAa,IAAb;;AAEA;;;;;;;AAOA,SAAKC,KAAL,GAAa,IAAb;AAvBa;AAwBb;;AAED;;;;;;;;8BAIW;AACVC,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,YAAhC;AACA;;;oCASgB;AAChBD,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,kBAAhC;AACA;;;sCAUkB;AAClBD,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,oBAAhC;AACA;;;2CAOuBC,I,EAAM;AAC7B,WAAOA,IAAP;AACA;;;4CAOwBC,K,EAAO;AAC/B,WAAOA,KAAP;AACA;;;gCAOY;AACZH,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,cAAhC;AACA;;;qCAOiB;AACjB;AACAD,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,WAAhC;AACA;;;mCASeG,Q,EAAU;AACzBC,WAAOC,IAAP,CAAYF,QAAZ,EAAsBG,OAAtB,CAA8B,eAAO;AACpC,SAAIH,SAASI,GAAT,EAAcC,WAAlB,EAA+B;AAC9B,sBAAWC,mBAAX,CAA+BN,SAASI,GAAT,EAAcC,WAA7C;AACA;AACD,KAJD;AAKA,WAAO,kBAAmBE,OAAnB,EAAP;AACA;;;oCASgB;AAChB,WAAO,kBAAmBA,OAAnB,EAAP;AACA;;;wBASIP,Q,EAAU;AAAA;;AACdJ,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,QAAhC;;AAEA,QAAIW,cAAc,EAAlB;;AAEAP,WAAOC,IAAP,CAAYF,QAAZ,EAAsBG,OAAtB,CAA8B,eAAO;AACpC,SAAIM,UAAUT,SAASI,GAAT,CAAd;AACA,SAAIM,WAAWD,QAAQE,IAAR,CAAa,OAAKnB,EAAlB,CAAf;AACAgB,iBAAYI,IAAZ,CAAiBF,QAAjB;AACA,KAJD;;AAMA,WAAO,kBAAmBG,GAAnB,CAAuBL,WAAvB,CAAP;AACA;;;2BAMO;AACP,WAAO,KAAKhB,EAAZ;AACA;;;8BAMU;AACV,WAAO,KAAKE,KAAZ;AACA;;;uCAYmB;AACnBE,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,qBAAhC;AACA;;;8BAMU;AACV,WAAO,KAAKF,KAAZ;AACA;;;0BAWM;AACNC,YAAQC,GAAR,CAAY,aAAa,IAAb,GAAoB,QAAhC;AACA,WAAO,kBAAmBU,OAAnB,EAAP;AACA;;;2BAQOf,E,EAAI;AACX,WAAO,YAAYA,EAAnB;AACA;;;yBAMKA,E,EAAI;AACT,SAAKA,EAAL,GAAUA,EAAV;AACA;;;4BAMQE,K,EAAO;AACf,SAAKA,KAAL,GAAaA,KAAb;AACA;;;4BAMQC,K,EAAO;AACf,SAAKA,KAAL,GAAaA,KAAb;AACA;;;8BAKU;AACV,WAAO,KAAKH,EAAZ;AACA;;;;;;AAIF;;;;;AAKAD,QAAOuB,eAAP,GAAyB,UAASC,MAAT,EAAiB;AACzC,SAAOA,kBAAkBxB,MAAzB;AACA,EAFD;;mBAIeA,M","file":"src/screen/Screen.js","sourcesContent":["'use strict';\n\nimport { getUid } from 'metal';\nimport { globalEval } from 'metal-dom';\nimport Cacheable from '../cacheable/Cacheable';\nimport CancellablePromise from 'metal-promise';\n\nclass Screen extends Cacheable {\n\n\t/**\n\t * Screen class is a special type of route handler that provides helper\n\t * utilities that adds lifecycle and methods to provide content to each\n\t * registered surface.\n\t * @constructor\n\t * @extends {Cacheable}\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds the screen id.\n\t\t * @type {string}\n\t\t * @protected\n\t\t */\n\t\tthis.id = this.makeId_(getUid());\n\n\t\t/**\n\t\t * Holds the screen meta tags. Relevant when the meta tags\n\t\t * should be updated when screen is rendered.\n\t\t */\n\t\tthis.metas = null;\n\n\t\t/**\n\t\t * Holds the screen title. Relevant when the page title should be\n\t\t * upadated when screen is rendered.\n\t\t * @type {?string=}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis.title = null;\n\t}\n\n\t/**\n\t * Fires when the screen is active. Allows a screen to perform any setup\n\t * that requires its DOM to be visible. Lifecycle.\n\t */\n\tactivate() {\n\t\tconsole.log('Screen [' + this + '] activate');\n\t}\n\n\t/**\n\t * Gives the Screen a chance to cancel the navigation and stop itself from\n\t * activating. Can be used, for example, to prevent navigation if a user\n\t * is not authenticated. Lifecycle.\n\t * @return {boolean=|?CancellablePromise=} If returns or resolves to true,\n\t *     the current screen is locked and the next nagivation interrupted.\n\t */\n\tbeforeActivate() {\n\t\tconsole.log('Screen [' + this + '] beforeActivate');\n\t}\n\n\t/**\n\t * Gives the Screen a chance to cancel the navigation and stop itself from\n\t * being deactivated. Can be used, for example, if the screen has unsaved\n\t * state. Lifecycle. Clean-up should not be preformed here, since the\n\t * navigation may still be cancelled. Do clean-up in deactivate.\n\t * @return {boolean=|?CancellablePromise=} If returns or resolves to true,\n\t *     the current screen is locked and the next nagivation interrupted.\n\t */\n\tbeforeDeactivate() {\n\t\tconsole.log('Screen [' + this + '] beforeDeactivate');\n\t}\n\n\t/**\n\t * Gives the Screen a chance format the path before history update.\n\t * @path {!string} path Navigation path.\n\t * @return {!string} Navigation path to use on history.\n\t */\n\tbeforeUpdateHistoryPath(path) {\n\t\treturn path;\n\t}\n\n\t/**\n\t * Gives the Screen a chance format the state before history update.\n\t * @path {!object} state History state.\n\t * @return {!object} History state to use on history.\n\t */\n\tbeforeUpdateHistoryState(state) {\n\t\treturn state;\n\t}\n\n\t/**\n\t * Allows a screen to do any cleanup necessary after it has been\n\t * deactivated, for example cancelling outstanding requests or stopping\n\t * timers. Lifecycle.\n\t */\n\tdeactivate() {\n\t\tconsole.log('Screen [' + this + '] deactivate');\n\t}\n\n\t/**\n\t * Dispose a screen, either after it is deactivated (in the case of a\n\t * non-cacheable view) or when the App is itself disposed for whatever\n\t * reason. Lifecycle.\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tconsole.log('Screen [' + this + '] dispose');\n\t}\n\n\t/**\n\t * Allows a screen to evaluate scripts before the element is made visible.\n\t * Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will\n\t *     pause the navigation until it is resolved.\n\t */\n\tevaluateScripts(surfaces) {\n\t\tObject.keys(surfaces).forEach(sId => {\n\t\t\tif (surfaces[sId].activeChild) {\n\t\t\t\tglobalEval.runScriptsInElement(surfaces[sId].activeChild);\n\t\t\t}\n\t\t});\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Allows a screen to evaluate styles before the element is made visible.\n\t * Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will\n\t *     pause the navigation until it is resolved.\n\t */\n\tevaluateStyles() {\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Allows a screen to perform any setup immediately before the element is\n\t * made visible. Lifecycle.\n\t * @param {!object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @return {?CancellablePromise=} This can return a promise, which will pause the\n\t *     navigation until it is resolved.\n\t */\n\tflip(surfaces) {\n\t\tconsole.log('Screen [' + this + '] flip');\n\n\t\tvar transitions = [];\n\n\t\tObject.keys(surfaces).forEach(sId => {\n\t\t\tvar surface = surfaces[sId];\n\t\t\tvar deferred = surface.show(this.id);\n\t\t\ttransitions.push(deferred);\n\t\t});\n\n\t\treturn CancellablePromise.all(transitions);\n\t}\n\n\t/**\n\t * Gets the screen id.\n\t * @return {string}\n\t */\n\tgetId() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * Gets the screen meta tags.\n\t * @return {NodeList|Node}\n\t */\n\tgetMetas() {\n\t\treturn this.metas;\n\t}\n\n\t/**\n\t * Returns the content for the given surface, or null if the surface isn't\n\t * used by this screen. This will be called when a screen is initially\n\t * constructed or, if a screen is non-cacheable, when navigated.\n\t * @param {!string} surfaceId The id of the surface DOM element.\n\t * @param {!Object} params Params extracted from the current path.\n\t * @return {?string|Element=} This can return a string or node representing\n\t *     the content of the surface. If returns falsy values surface default\n\t *     content is restored.\n\t */\n\tgetSurfaceContent() {\n\t\tconsole.log('Screen [' + this + '] getSurfaceContent');\n\t}\n\n\t/**\n\t * Gets the screen title.\n\t * @return {?string=}\n\t */\n\tgetTitle() {\n\t\treturn this.title;\n\t}\n\n\t/**\n\t * Returns all contents for the surfaces. This will pass the loaded content\n\t * to <code>Screen.load</code> with all information you\n\t * need to fulfill the surfaces. Lifecycle.\n\t * @param {!string=} path The requested path.\n\t * @return {!CancellablePromise} This can return a string representing the\n\t *     contents of the surfaces or a promise, which will pause the navigation\n\t *     until it is resolved. This is useful for loading async content.\n\t */\n\tload() {\n\t\tconsole.log('Screen [' + this + '] load');\n\t\treturn CancellablePromise.resolve();\n\t}\n\n\t/**\n\t * Makes the id for the screen.\n\t * @param {!string} id The screen id the content belongs too.\n\t * @return {string}\n\t * @private\n\t */\n\tmakeId_(id) {\n\t\treturn 'screen_' + id;\n\t}\n\n\t/**\n\t * Sets the screen id.\n\t * @param {!string} id\n\t */\n\tsetId(id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Sets the screen meta tags.\n\t * @param {NodeList|Node} metas\n\t */\n\tsetMetas(metas) {\n\t\tthis.metas = metas;\n\t}\n\n\t/**\n\t * Sets the screen title.\n\t * @param {?string=} title\n\t */\n\tsetTitle(title) {\n\t\tthis.title = title;\n\t}\n\n\t/**\n\t * @return {string}\n\t */\n\ttoString() {\n\t\treturn this.id;\n\t}\n\n}\n\n/**\n * @param {*} object\n * @return {boolean} Whether a given instance implements\n * <code>Screen</code>.\n */\nScreen.isImplementedBy = function(object) {\n\treturn object instanceof Screen;\n};\n\nexport default Screen;\n"],"sourceRoot":"/source/"}