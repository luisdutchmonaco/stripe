{"version":3,"sources":["Route.js"],"names":["Route","path","handler","Error","parsedData_","tokens","regex","buildParsedData_","value","RegExp","search"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAKMA,K;;AAEL;;;;;;AAMA,iBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAC1B,OAAI,CAAC,4BAAgBD,IAAhB,CAAL,EAA4B;AAC3B,UAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD,OAAI,CAAC,uBAAWD,OAAX,CAAL,EAA0B;AACzB,UAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACA;;AAED;;;;;;AAMA,QAAKD,OAAL,GAAeA,OAAf;;AAEA;;;;;AAKA,QAAKD,IAAL,GAAYA,IAAZ;AACA;;AAED;;;;;;;;;sCAKmB;AAClB,QAAI,CAAC,KAAKG,WAAV,EAAuB;AACtB,SAAIC,SAAS,uBAAM,KAAKJ,IAAX,CAAb;AACA,SAAIK,QAAQ,yBAAQD,MAAR,CAAZ;AACA,UAAKD,WAAL,GAAmB;AAClBE,kBADkB;AAElBD;AAFkB,MAAnB;AAIA;AACD,WAAO,KAAKD,WAAZ;AACA;;;iCAQaH,I,EAAM;AACnB,QAAI,qBAAS,KAAKA,IAAd,CAAJ,EAAyB;AACxB,YAAO,6BAAY,KAAKM,gBAAL,GAAwBF,MAApC,EAA4CJ,IAA5C,CAAP;AACA;AACD,WAAO,EAAP;AACA;;;gCAMY;AACZ,WAAO,KAAKC,OAAZ;AACA;;;6BAMS;AACT,WAAO,KAAKD,IAAZ;AACA;;;+BAOWO,K,EAAO;AAClB,QAAIP,OAAO,KAAKA,IAAhB;;AAEA,QAAI,uBAAWA,IAAX,CAAJ,EAAsB;AACrB,YAAOA,KAAKO,KAAL,CAAP;AACA;AACD,QAAI,qBAASP,IAAT,CAAJ,EAAoB;AACnBA,YAAO,KAAKM,gBAAL,GAAwBD,KAA/B;AACA;AACD,QAAIL,gBAAgBQ,MAApB,EAA4B;AAC3B,YAAOD,MAAME,MAAN,CAAaT,IAAb,IAAqB,CAAC,CAA7B;AACA;;AAED,WAAO,KAAP;AACA;;;;;;mBAIaD,K","file":"src/route/Route.js","sourcesContent":["'use strict';\n\nimport { isDefAndNotNull, isFunction, isString } from 'metal';\nimport { extractData, parse, toRegex } from 'metal-path-parser';\n\nclass Route {\n\n\t/**\n\t * Route class.\n\t * @param {!string|RegExp|Function} path\n\t * @param {!Function} handler\n\t * @constructor\n\t */\n\tconstructor(path, handler) {\n\t\tif (!isDefAndNotNull(path)) {\n\t\t\tthrow new Error('Route path not specified.');\n\t\t}\n\t\tif (!isFunction(handler)) {\n\t\t\tthrow new Error('Route handler is not a function.');\n\t\t}\n\n\t\t/**\n\t\t * Defines the handler which will execute once a URL in the application\n\t\t * matches the path.\n\t\t * @type {!Function}\n\t\t * @protected\n\t\t */\n\t\tthis.handler = handler;\n\n\t\t/**\n\t\t * Defines the path which will trigger the route handler.\n\t\t * @type {!string|RegExp|Function}\n\t\t * @protected\n\t\t */\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t* Builds parsed data (regex and tokens) for this route.\n\t* @return {!Object}\n\t* @protected\n\t*/\n\tbuildParsedData_() {\n\t\tif (!this.parsedData_) {\n\t\t\tvar tokens = parse(this.path);\n\t\t\tvar regex = toRegex(tokens);\n\t\t\tthis.parsedData_ = {\n\t\t\t\tregex,\n\t\t\t\ttokens\n\t\t\t};\n\t\t}\n\t\treturn this.parsedData_;\n\t}\n\n\t/**\n\t * Extracts param data from the given path, according to this route.\n\t * @param {string} path The url path to extract params from.\n\t * @return {Object} The extracted data, if the path matches this route, or\n\t *     null otherwise.\n\t */\n\textractParams(path) {\n\t\tif (isString(this.path)) {\n\t\t\treturn extractData(this.buildParsedData_().tokens, path);\n\t\t}\n\t\treturn {};\n\t}\n\n\t/**\n\t * Gets the route handler.\n\t * @return {!Function}\n\t */\n\tgetHandler() {\n\t\treturn this.handler;\n\t}\n\n\t/**\n\t * Gets the route path.\n\t * @return {!string|RegExp|Function}\n\t */\n\tgetPath() {\n\t\treturn this.path;\n\t}\n\n\t/**\n \t * Matches if the router can handle the tested path.\n \t * @param {!string} value Path to test (may contain the querystring part).\n\t * @return {boolean} Returns true if matches any route.\n\t */\n\tmatchesPath(value) {\n\t\tvar path = this.path;\n\n\t\tif (isFunction(path)) {\n\t\t\treturn path(value);\n\t\t}\n\t\tif (isString(path)) {\n\t\t\tpath = this.buildParsedData_().regex;\n\t\t}\n\t\tif (path instanceof RegExp) {\n\t\t\treturn value.search(path) > -1;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nexport default Route;\n"],"sourceRoot":"/source/"}