{"version":3,"sources":["TreeNode.js"],"names":["TreeNode","value","value_","parent_","children_","child","assertChildHasNoParent","setParent","push","node","current","getParent","ancestors","index","getChildren","EMPTY_ARRAY","length","depth","root","getChildCount","remove","parent","opt_preorderFn","opt_postorderFn","forEach","traverse","Error"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KASMA,Q;AAEL,oBAAYC,KAAZ,EAAmB;AAAA;;AAClB;;;;AAIA,QAAKC,MAAL,GAAcD,KAAd;;AAEA;;;;AAIA,QAAKE,OAAL,GAAe,IAAf;;AAEA;;;;AAIA,QAAKC,SAAL,GAAiB,IAAjB;AACA;;AAED;;;;;;;;4BAISC,K,EAAO;AACfC,2BAAuBD,KAAvB;AACAA,UAAME,SAAN,CAAgB,IAAhB;AACA,SAAKH,SAAL,GAAiB,KAAKA,SAAL,IAAkB,EAAnC;AACA,SAAKA,SAAL,CAAeI,IAAf,CAAoBH,KAApB;AACA;;;4BAOQI,I,EAAM;AACd,QAAIC,UAAUD,KAAKE,SAAL,EAAd;AACA,WAAOD,OAAP,EAAgB;AACf,SAAIA,YAAY,IAAhB,EAAsB;AACrB,aAAO,IAAP;AACA;AACDA,eAAUA,QAAQC,SAAR,EAAV;AACA;AACD,WAAO,KAAP;AACA;;;kCAKc;AACd,QAAIC,YAAY,EAAhB;AACA,QAAIH,OAAO,KAAKE,SAAL,EAAX;AACA,WAAOF,IAAP,EAAa;AACZG,eAAUJ,IAAV,CAAeC,IAAf;AACAA,YAAOA,KAAKE,SAAL,EAAP;AACA;AACD,WAAOC,SAAP;AACA;;;8BAQUC,K,EAAO;AACjB,WAAO,KAAKC,WAAL,GAAmBD,KAAnB,KAA6B,IAApC;AACA;;;iCAKa;AACb,WAAO,KAAKT,SAAL,IAAkBJ,SAASe,WAAlC;AACA;;;mCAKe;AACf,WAAO,KAAKD,WAAL,GAAmBE,MAA1B;AACA;;;8BAKU;AACV,QAAIC,QAAQ,CAAZ;AACA,QAAIR,OAAO,IAAX;AACA,WAAOA,KAAKE,SAAL,EAAP,EAAyB;AACxBM;AACAR,YAAOA,KAAKE,SAAL,EAAP;AACA;AACD,WAAOM,KAAP;AACA;;;+BAKW;AACX,WAAO,KAAKd,OAAZ;AACA;;;6BAMS;AACT,QAAIe,OAAO,IAAX;AACA,WAAOA,KAAKP,SAAL,EAAP,EAAyB;AACxBO,YAAOA,KAAKP,SAAL,EAAP;AACA;AACD,WAAOO,IAAP;AACA;;;8BAMU;AACV,WAAO,KAAKhB,MAAZ;AACA;;;4BAKQ;AACR,WAAO,CAAC,KAAKiB,aAAL,EAAR;AACA;;;+BAOWd,K,EAAO;AAClB,QAAI,aAAMe,MAAN,CAAa,KAAKN,WAAL,EAAb,EAAiCT,KAAjC,CAAJ,EAA6C;AAC5C,YAAOA,KAAP;AACA;AACD,WAAO,IAAP;AACA;;;6BASSgB,M,EAAQ;AACjB,SAAKlB,OAAL,GAAekB,MAAf;AACA;;;4BAoBQC,c,EAAgBC,e,EAAiB;AACzC,QAAID,cAAJ,EAAoB;AACnBA,oBAAe,IAAf;AACA;AACD,SAAKR,WAAL,GAAmBU,OAAnB,CAA2B,UAACnB,KAAD;AAAA,YAAWA,MAAMoB,QAAN,CAAeH,cAAf,EAA+BC,eAA/B,CAAX;AAAA,KAA3B;AACA,QAAIA,eAAJ,EAAqB;AACpBA,qBAAgB,IAAhB;AACA;AACD;;;;;;AAIF;;;;AAIAvB,UAASe,WAAT,GAAuB,EAAvB;;AAEA;;;;;AAKA,KAAMT,yBAAyB,SAAzBA,sBAAyB,CAASD,KAAT,EAAgB;AAC9C,MAAIA,MAAMM,SAAN,EAAJ,EAAuB;AACtB,SAAM,IAAIe,KAAJ,CAAU,+BAAV,CAAN;AACA;AACD,EAJD;;mBAMe1B,Q","file":"node_modules/metal-structs/src/TreeNode.js","sourcesContent":["'use strict';\n\nimport { array } from 'metal';\n\n/**\n * Generic tree node data structure with arbitrary number of child nodes.\n * @param {V} value Value.\n * @constructor\n */\nclass TreeNode {\n\n\tconstructor(value) {\n\t\t/**\n\t\t * The value.\n\t\t * @private {V}\n\t\t */\n\t\tthis.value_ = value;\n\n\t\t/**\n\t\t * Reference to the parent node or null if it has no parent.\n\t\t * @private {TreeNode}\n\t\t */\n\t\tthis.parent_ = null;\n\n\t\t/**\n\t\t * Child nodes or null in case of leaf node.\n\t\t * @private {Array<!TreeNode>}\n\t\t */\n\t\tthis.children_ = null;\n\t}\n\n\t/**\n\t * Appends a child node to this node.\n\t * @param {!TreeNode} child Orphan child node.\n\t */\n\taddChild(child) {\n\t\tassertChildHasNoParent(child);\n\t\tchild.setParent(this);\n\t\tthis.children_ = this.children_ || [];\n\t\tthis.children_.push(child);\n\t}\n\n\t/**\n\t * Tells whether this node is the ancestor of the given node.\n\t * @param {!TreeNode} node A node.\n\t * @return {boolean} Whether this node is the ancestor of {@code node}.\n\t */\n\tcontains(node) {\n\t\tlet current = node.getParent();\n\t\twhile (current) {\n\t\t\tif (current === this) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcurrent = current.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.\n\t */\n\tgetAncestors() {\n\t\tlet ancestors = [];\n\t\tlet node = this.getParent();\n\t\twhile (node) {\n\t\t\tancestors.push(node);\n\t\t\tnode = node.getParent();\n\t\t}\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Gets the child node of this node at the given index.\n\t * @param {number} index Child index.\n\t * @return {?TreeNode} The node at the given index\n\t * or null if not found.\n\t */\n\tgetChildAt(index) {\n\t\treturn this.getChildren()[index] || null;\n\t}\n\n\t/**\n\t * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.\n\t */\n\tgetChildren() {\n\t\treturn this.children_ || TreeNode.EMPTY_ARRAY;\n\t}\n\n\t/**\n\t * @return {number} The number of children.\n\t */\n\tgetChildCount() {\n\t\treturn this.getChildren().length;\n\t}\n\n\t/**\n\t * @return {number} The number of ancestors of the node.\n\t */\n\tgetDepth() {\n\t\tlet depth = 0;\n\t\tlet node = this;\n\t\twhile (node.getParent()) {\n\t\t\tdepth++;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\treturn depth;\n\t}\n\n\t/**\n\t * @return {?TreeNode} Parent node or null if it has no parent.\n\t */\n\tgetParent() {\n\t\treturn this.parent_;\n\t}\n\n\t/**\n\t * @return {!TreeNode} The root of the tree structure, i.e. the farthest\n\t * ancestor of the node or the node itself if it has no parents.\n\t */\n\tgetRoot() {\n\t\tlet root = this;\n\t\twhile (root.getParent()) {\n\t\t\troot = root.getParent();\n\t\t}\n\t\treturn root;\n\t}\n\n\t/**\n\t * Gets the value.\n\t * @return {V} The value.\n\t */\n\tgetValue() {\n\t\treturn this.value_;\n\t}\n\n\t/**\n\t * @return {boolean} Whether the node is a leaf node.\n\t */\n\tisLeaf() {\n\t\treturn !this.getChildCount();\n\t}\n\n\t/**\n\t * Removes the given child node of this node.\n\t * @param {TreeNode} child The node to remove.\n\t * @return {TreeNode} The removed node if any, null otherwise.\n\t */\n\tremoveChild(child) {\n\t\tif (array.remove(this.getChildren(), child)) {\n\t\t\treturn child;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the parent node of this node. The callers must ensure that the\n\t * parent node and only that has this node among its children.\n\t * @param {TreeNode} parent The parent to set. If null, the node will be\n\t * detached from the tree.\n\t * @protected\n\t */\n\tsetParent(parent) {\n\t\tthis.parent_ = parent;\n\t}\n\n\t/**\n\t * Traverses the subtree. The first callback starts with this node,\n\t * and visits the descendant nodes depth-first, in preorder.\n\t * The second callback, starts with deepest child then visits\n\t * the ancestor nodes depth-first, in postorder. E.g.\n\t *\n\t *  \t A\n\t *    / \\\n\t *   B   C\n\t *  /   / \\\n\t * D   E   F\n\t *\n\t * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']\n\t * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']\n\t *\n\t * @param {function=} opt_preorderFn The callback to execute when visiting a node.\n\t * @param {function=} opt_postorderFn The callback to execute before leaving a node.\n\t */\n\ttraverse(opt_preorderFn, opt_postorderFn) {\n\t\tif (opt_preorderFn) {\n\t\t\topt_preorderFn(this);\n\t\t}\n\t\tthis.getChildren().forEach((child) => child.traverse(opt_preorderFn, opt_postorderFn));\n\t\tif (opt_postorderFn) {\n\t\t\topt_postorderFn(this);\n\t\t}\n\t}\n\n}\n\n/**\n * Constant for empty array to avoid unnecessary allocations.\n * @private\n */\nTreeNode.EMPTY_ARRAY = [];\n\n/**\n * Asserts that child has no parent.\n * @param {TreeNode} child A child.\n * @private\n */\nconst assertChildHasNoParent = function(child) {\n\tif (child.getParent()) {\n\t\tthrow new Error('Cannot add child with parent.');\n\t}\n};\n\nexport default TreeNode;\n"],"sourceRoot":"/source/"}