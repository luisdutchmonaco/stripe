{"version":3,"sources":["pathParser.js"],"names":["parse","toRegex","extractData","REGEX","convertMatchesToObj","matches","match","prefix","name","paramPattern","unnamedPattern","modifier","convertTokensToRegex","tokens","regex","i","length","isString","escape","capture","encloseNonCapturingGroup","pattern","repeat","optional","partial","RegExp","makeTrailingSlashOptional","str","replace","test","routeOrTokens","route","unnamedCount","currPath","index","exec","data","slice","push","substr","path","paramIndex","value","isDef","split"],"mappings":"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","file":"node_modules/metal-path-parser/src/pathParser.js","sourcesContent":["'use strict';\n\nimport core from 'metal';\n\nconst REGEX = /([\\/])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])*)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?)/g;\n\n/**\n * Converts the given array of regex matches to a more readable object format.\n * @param {!Array<string>} matches\n * @return {!Object}\n */\nfunction convertMatchesToObj(matches) {\n\treturn {\n\t\tmatch: matches[0],\n\t\tprefix: matches[1],\n\t\tname: matches[2],\n\t\tparamPattern: matches[3],\n\t\tunnamedPattern: matches[4],\n\t\tmodifier: matches[5]\n\t};\n}\n\n/**\n * Converts the given tokens parsed from a route format string to a regex.\n * @param {!Array<string|!Object>} tokens\n * @return {!RegExp}\n */\nfunction convertTokensToRegex(tokens) {\n\tlet regex = '';\n\tfor (let i = 0; i < tokens.length; i++) {\n\t\tif (core.isString(tokens[i])) {\n\t\t\tregex += escape(tokens[i]);\n\t\t} else {\n\t\t\tlet capture = encloseNonCapturingGroup(tokens[i].pattern);\n\t\t\tif (tokens[i].repeat) {\n\t\t\t\tcapture += encloseNonCapturingGroup('\\\\/' + capture) + '*';\n\t\t\t}\n\t\t\tcapture = escape(tokens[i].prefix) + `(${capture})`;\n\t\t\tif (tokens[i].optional) {\n\t\t\t\tif (!tokens[i].partial) {\n\t\t\t\t\tcapture = encloseNonCapturingGroup(capture);\n\t\t\t\t}\n\t\t\t\tcapture += '?';\n\t\t\t}\n\t\t\tregex += capture;\n\t\t}\n\t}\n\treturn new RegExp('^' + makeTrailingSlashOptional(regex) + '$');\n}\n\n/**\n * Encloses the given regex pattern into a non capturing group.\n * @param {string} pattern\n * @return {string}\n */\nfunction encloseNonCapturingGroup(pattern) {\n\treturn `(?:${pattern})`;\n}\n\n/**\n * Escapes the given string to show up in the path regex.\n * @param {string} str\n * @return {string}\n */\nfunction escape(str) {\n\treturn str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Makes trailing slash optional on paths.\n * @param {string} regex\n * @param {string}\n */\nfunction makeTrailingSlashOptional(regex) {\n\tif (/\\/$/.test(regex)) {\n\t\tregex += '?';\n\t} else {\n\t\tregex += '\\\\/?';\n\t}\n\treturn regex;\n}\n\n/**\n * Parses the given route format string into tokens representing its contents.\n * @param {!Array|string} routeOrTokens Either a route format string or tokens\n *     previously parsed via the `parse` function.\n * @return {!Array<string|!Object>} An array of tokens that can be either plain\n *     strings (part of the route) or objects containing informations on params.\n */\nexport function parse(routeOrTokens) {\n\tif (!core.isString(routeOrTokens)) {\n\t\treturn routeOrTokens;\n\t}\n\n\tconst route = routeOrTokens;\n\tlet unnamedCount = 0;\n\tconst tokens = [];\n\tlet currPath = '';\n\tlet index = 0;\n\n\tlet matches = REGEX.exec(route);\n\twhile (matches) {\n\t\tconst data = convertMatchesToObj(matches);\n\n\t\tcurrPath = route.slice(index, matches.index);\n\t\tindex = matches.index + data.match.length;\n\t\ttokens.push(currPath);\n\n\t\ttokens.push({\n\t\t\tname: data.name ? data.name : '' + unnamedCount++,\n\t\t\tpartial: route[index] && route[index] !== data.prefix,\n\t\t\tprefix: data.prefix || '',\n\t\t\tpattern: data.paramPattern || data.unnamedPattern || '[^\\\\/]+',\n\t\t\trepeat: data.modifier === '*' || data.modifier === '+',\n\t\t\toptional: data.modifier === '*' || data.modifier === '?'\n\t\t});\n\n\t\tmatches = REGEX.exec(route);\n\t}\n\n\tif (index < route.length) {\n\t\ttokens.push(route.substr(index));\n\t}\n\treturn tokens;\n}\n\n/**\n * Converts the given route format string to a regex that can extract param\n * data from paths matching it.\n * @param {!Array|string} routeOrTokens Either a route format string or tokens\n *     previously parsed via the `parse` function.\n * @return {!RegExp}\n */\nexport function toRegex(routeOrTokens) {\n\treturn convertTokensToRegex(parse(routeOrTokens));\n}\n\n/**\n * Extracts data from the given path according to the specified route format.\n * @param {!Array|string} routeOrTokens Either a route format string or tokens\n *     previously parsed via the `parse` function.\n * @param {string} The path to extract param data from.\n * @return {Object<string, string>} The data object, or null if the path doesn't\n *     match the given format.\n */\nexport function extractData(routeOrTokens, path) {\n\tconst data = {};\n\tconst tokens = parse(routeOrTokens);\n\tconst match = path.match(convertTokensToRegex(tokens));\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tlet paramIndex = 1;\n\tfor (let i = 0; i < tokens.length; i++) {\n\t\tif (!core.isString(tokens[i])) {\n\t\t\tlet value = match[paramIndex++];\n\t\t\tif (core.isDef(value)) {\n\t\t\t\tif (tokens[i].repeat) {\n\t\t\t\t\tvalue = value.split('/');\n\t\t\t\t}\n\t\t\t\tdata[tokens[i].name] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n"],"sourceRoot":"/source/"}