{"version":3,"sources":["Promise.js"],"names":["Thenable","prototype","then","IMPLEMENTED_BY_PROP","addImplementation","ctor","$goog_Thenable","isImplementedBy","object","e","partial","fn","args","Array","slice","call","arguments","newArgs","push","apply","CancellablePromise","resolver","opt_context","state_","State_","PENDING","result_","undefined","parent_","callbackEntries_","executing_","UNHANDLED_REJECTION_DELAY","unhandledRejectionId_","hadUnhandledRejection_","self","value","resolve_","FULFILLED","reason","REJECTED","BLOCKED","CallbackEntry_","resolve","opt_value","reject","opt_reason","race","promises","length","i","promise","all","toFulfill","values","onFulfill","index","onReject","firstFulfilled","toReject","reasons","opt_onFulfilled","opt_onRejected","addChildPromise_","thenAlways","onResolved","callback","err","handleRejection_","addCallbackEntry_","child","onRejected","onFulfilled","thenCatch","catch","cancel","opt_message","run","CancellationError","IS_CANCELLATION_ERROR","cancelInternal_","cancelChild_","childPromise","childCount","childIndex","entry","callbackEntry","splice","executeCallback_","scheduleCallbacks_","result","unblockAndFulfill_","Error","unblockAndReject_","state","x","TypeError","tryThen_","addUnhandledRejection_","thenable","called","executeCallbacks_","entries","removeUnhandledRejection_","p","clearTimeout","setTimeout","throwException","setUnhandledRejectionHandler","handler","message","name"],"mappings":"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","file":"node_modules/metal-promise/src/promise/Promise.js","sourcesContent":["/*!\n * Promises polyfill from Google's Closure Library.\n *\n *      Copyright 2013 The Closure Library Authors. All Rights Reserved.\n *\n * NOTE(eduardo): Promise support is not ready on all supported browsers,\n * therefore metal-promise is temporarily using Google's promises as polyfill.\n * It supports cancellable promises and has clean and fast implementation.\n */\n\n'use strict';\n\nimport { isDef, isFunction, isObject } from 'metal';\nimport { async } from 'metal';\n\n/**\n * Provides a more strict interface for Thenables in terms of\n * http://promisesaplus.com for interop with {@see CancellablePromise}.\n *\n * @interface\n * @extends {IThenable.<TYPE>}\n * @template TYPE\n */\nvar Thenable = function() {};\n\n/**\n * Adds callbacks that will operate on the result of the Thenable, returning a\n * new child Promise.\n *\n * If the Thenable is fulfilled, the {@code onFulfilled} callback will be\n * invoked with the fulfillment value as argument, and the child Promise will\n * be fulfilled with the return value of the callback. If the callback throws\n * an exception, the child Promise will be rejected with the thrown value\n * instead.\n *\n * If the Thenable is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value of the callback or thrown value.\n *\n * @param {?(function(this:THIS, TYPE):\n *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fullfilled.\n * @param {?(function(*): *)=} opt_onRejected A function that will be invoked\n *     with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the\n *     result of the fulfillment or rejection callback.\n * @template RESULT,THIS\n */\nThenable.prototype.then = function() {};\n\n\n/**\n * An expando property to indicate that an object implements\n * {@code Thenable}.\n *\n * {@see addImplementation}.\n *\n * @const\n */\nThenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';\n\n\n/**\n * Marks a given class (constructor) as an implementation of Thenable, so\n * that we can query that fact at runtime. The class must have already\n * implemented the interface.\n * Exports a 'then' method on the constructor prototype, so that the objects\n * also implement the extern {@see Thenable} interface for interop with\n * other Promise implementations.\n * @param {function(new:Thenable,...[?])} ctor The class constructor. The\n *     corresponding class must have already implemented the interface.\n */\nThenable.addImplementation = function(ctor) {\n  ctor.prototype.then = ctor.prototype.then;\n  ctor.prototype.$goog_Thenable = true;\n};\n\n\n/**\n * @param {*} object\n * @return {boolean} Whether a given instance implements {@code Thenable}.\n *     The class/superclass of the instance must call {@code addImplementation}.\n */\nThenable.isImplementedBy = function(object) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object.$goog_Thenable;\n  } catch (e) {\n    // Property access seems to be forbidden.\n    return false;\n  }\n};\n\n\n/**\n * Like bind(), except that a 'this object' is not required. Useful when the\n * target function is already bound.\n *\n * Usage:\n * var g = partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n */\nvar partial = function(fn) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Clone the array (with slice()) and append additional arguments\n    // to the existing arguments.\n    var newArgs = args.slice();\n    newArgs.push.apply(newArgs, arguments);\n    return fn.apply(this, newArgs);\n  };\n};\n\n/**\n * Promises provide a result that may be resolved asynchronously. A Promise may\n * be resolved by being fulfilled or rejected with a value, which will be known\n * as the fulfillment value or the rejection reason. Whether fulfilled or\n * rejected, the Promise result is immutable once it is set.\n *\n * Promises may represent results of any type, including undefined. Rejection\n * reasons are typically Errors, but may also be of any type. Closure Promises\n * allow for optional type annotations that enforce that fulfillment values are\n * of the appropriate types at compile time.\n *\n * The result of a Promise is accessible by calling {@code then} and registering\n * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise\n * resolves, the relevant callbacks are invoked with the fulfillment value or\n * rejection reason as argument. Callbacks are always invoked in the order they\n * were registered, even when additional {@code then} calls are made from inside\n * another callback. A callback is always run asynchronously sometime after the\n * scope containing the registering {@code then} invocation has returned.\n *\n * If a Promise is resolved with another Promise, the first Promise will block\n * until the second is resolved, and then assumes the same result as the second\n * Promise. This allows Promises to depend on the results of other Promises,\n * linking together multiple asynchronous operations.\n *\n * This implementation is compatible with the Promises/A+ specification and\n * passes that specification's conformance test suite. A Closure Promise may be\n * resolved with a Promise instance (or sufficiently compatible Promise-like\n * object) created by other Promise implementations. From the specification,\n * Promise-like objects are known as \"Thenables\".\n *\n * @see http://promisesaplus.com/\n *\n * @param {function(\n *             this:RESOLVER_CONTEXT,\n *             function((TYPE|IThenable.<TYPE>|Thenable)),\n *             function(*)): void} resolver\n *     Initialization function that is invoked immediately with {@code resolve}\n *     and {@code reject} functions as arguments. The Promise is resolved or\n *     rejected with the first argument passed to either function.\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\n *     resolver function. If unspecified, the resolver function will be executed\n *     in the default scope.\n * @constructor\n * @struct\n * @final\n * @implements {Thenable.<TYPE>}\n * @template TYPE,RESOLVER_CONTEXT\n */\nvar CancellablePromise = function(resolver, opt_context) {\n  /**\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\n   * BLOCKED.\n   * @private {CancellablePromise.State_}\n   */\n  this.state_ = CancellablePromise.State_.PENDING;\n\n  /**\n   * The resolved result of the Promise. Immutable once set with either a\n   * fulfillment value or rejection reason.\n   * @private {*}\n   */\n  this.result_ = undefined;\n\n  /**\n   * For Promises created by calling {@code then()}, the originating parent.\n   * @private {CancellablePromise}\n   */\n  this.parent_ = null;\n\n  /**\n   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to\n   * this Promise by calls to {@code then()}.\n   * @private {Array.<CancellablePromise.CallbackEntry_>}\n   */\n  this.callbackEntries_ = null;\n\n  /**\n   * Whether the Promise is in the queue of Promises to execute.\n   * @private {boolean}\n   */\n  this.executing_ = false;\n\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    /**\n     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\n     * cleared only if an {@code onRejected} callback is invoked for the\n     * Promise (or one of its descendants) before the delay is exceeded.\n     *\n     * If the rejection is not handled before the timeout completes, the\n     * rejection reason is passed to the unhandled rejection handler.\n     * @private {number}\n     */\n    this.unhandledRejectionId_ = 0;\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    /**\n     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a\n     * boolean that is set if the Promise is rejected, and reset to false if an\n     * {@code onRejected} callback is invoked for the Promise (or one of its\n     * descendants). If the rejection is not handled before the next timestep,\n     * the rejection reason is passed to the unhandled rejection handler.\n     * @private {boolean}\n     */\n    this.hadUnhandledRejection_ = false;\n  }\n\n  try {\n    var self = this;\n    resolver.call(\n      opt_context, function(value) {\n        self.resolve_(CancellablePromise.State_.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(CancellablePromise.State_.REJECTED, reason);\n      });\n  } catch (e) {\n    this.resolve_(CancellablePromise.State_.REJECTED, e);\n  }\n};\n\n/**\n * The delay in milliseconds before a rejected Promise's reason is passed to\n * the rejection handler. By default, the rejection handler rethrows the\n * rejection reason so that it appears in the developer console or\n * {@code window.onerror} handler.\n * Rejections are rethrown as quickly as possible by default. A negative value\n * disables rejection handling entirely.\n * @type {number}\n */\nCancellablePromise.UNHANDLED_REJECTION_DELAY = 0;\n\n\n/**\n * The possible internal states for a Promise. These states are not directly\n * observable to external callers.\n * @enum {number}\n * @private\n */\nCancellablePromise.State_ = {\n  /** The Promise is waiting for resolution. */\n  PENDING: 0,\n\n  /** The Promise is blocked waiting for the result of another Thenable. */\n  BLOCKED: 1,\n\n  /** The Promise has been resolved with a fulfillment value. */\n  FULFILLED: 2,\n\n  /** The Promise has been resolved with a rejection reason. */\n  REJECTED: 3\n};\n\n\n/**\n * Typedef for entries in the callback chain. Each call to {@code then},\n * {@code thenCatch}, or {@code thenAlways} creates an entry containing the\n * functions that may be invoked once the Promise is resolved.\n *\n * @typedef {{\n *   child: CancellablePromise,\n *   onFulfilled: function(*),\n *   onRejected: function(*)\n * }}\n * @private\n */\nCancellablePromise.CallbackEntry_ = null;\n\n\n/**\n * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value\n * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved\n *     with the given value.\n * @template TYPE\n */\nCancellablePromise.resolve = function(opt_value) {\n  return new CancellablePromise(function(resolve) {\n      resolve(opt_value);\n    });\n};\n\n\n/**\n * @param {*=} opt_reason\n * @return {!CancellablePromise} A new Promise that is immediately rejected with the\n *     given reason.\n */\nCancellablePromise.reject = function(opt_reason) {\n  return new CancellablePromise(function(resolve, reject) {\n      reject(opt_reason);\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the\n *     first Promise (or Promise-like) input to complete.\n * @template TYPE\n */\nCancellablePromise.race = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      if (!promises.length) {\n        resolve(undefined);\n      }\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(resolve, reject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of\n *     every fulfilled value once every input Promise (or Promise-like) is\n *     successfully fulfilled, or is rejected by the first rejection result.\n * @template TYPE\n */\nCancellablePromise.all = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toFulfill = promises.length;\n      var values = [];\n\n      if (!toFulfill) {\n        resolve(values);\n        return;\n      }\n\n      var onFulfill = function(index, value) {\n        toFulfill--;\n        values[index] = value;\n        if (toFulfill === 0) {\n          resolve(values);\n        }\n      };\n\n      var onReject = function(reason) {\n        reject(reason);\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(partial(onFulfill, i), onReject);\n      }\n    });\n};\n\n\n/**\n * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises\n * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of\n *     the first input to be fulfilled, or is rejected with a list of every\n *     rejection reason if all inputs are rejected.\n * @template TYPE\n */\nCancellablePromise.firstFulfilled = function(promises) {\n  return new CancellablePromise(function(resolve, reject) {\n      var toReject = promises.length;\n      var reasons = [];\n\n      if (!toReject) {\n        resolve(undefined);\n        return;\n      }\n\n      var onFulfill = function(value) {\n        resolve(value);\n      };\n\n      var onReject = function(index, reason) {\n        toReject--;\n        reasons[index] = reason;\n        if (toReject === 0) {\n          reject(reasons);\n        }\n      };\n\n      for (var i = 0, promise; (promise = promises[i]); i++) {\n        promise.then(onFulfill, partial(onReject, i));\n      }\n    });\n};\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise, returning a\n * new child Promise.\n *\n * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked\n * with the fulfillment value as argument, and the child Promise will be\n * fulfilled with the return value of the callback. If the callback throws an\n * exception, the child Promise will be rejected with the thrown value instead.\n *\n * If the Promise is rejected, the {@code onRejected} callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value (or thrown value) of the callback.\n *\n * @override\n */\nCancellablePromise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  return this.addChildPromise_(\n    isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\n    isFunction(opt_onRejected) ? opt_onRejected : null,\n    opt_context);\n};\nThenable.addImplementation(CancellablePromise);\n\n\n/**\n * Adds a callback that will be invoked whether the Promise is fulfilled or\n * rejected. The callback receives no argument, and no new child Promise is\n * created. This is useful for ensuring that cleanup takes place after certain\n * asynchronous operations. Callbacks added with {@code thenAlways} will be\n * executed in the same order with other calls to {@code then},\n * {@code thenAlways}, or {@code thenCatch}.\n *\n * Since it does not produce a new child Promise, cancellation propagation is\n * not prevented by adding callbacks with {@code thenAlways}. A Promise that has\n * a cleanup handler added with {@code thenAlways} will be canceled if all of\n * its children created by {@code then} (or {@code thenCatch}) are canceled.\n *\n * @param {function(this:THIS): void} onResolved A function that will be invoked\n *     when the Promise is resolved.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.\n * @template THIS\n */\nCancellablePromise.prototype.thenAlways = function(onResolved, opt_context) {\n  var callback = function() {\n    try {\n      // Ensure that no arguments are passed to onResolved.\n      onResolved.call(opt_context);\n    } catch (err) {\n      CancellablePromise.handleRejection_.call(null, err);\n    }\n  };\n\n  this.addCallbackEntry_({\n    child: null,\n    onRejected: callback,\n    onFulfilled: callback\n  });\n  return this;\n};\n\n\n/**\n * Adds a callback that will be invoked only if the Promise is rejected. This\n * is equivalent to {@code then(null, onRejected)}.\n *\n * @param {!function(this:THIS, *): *} onRejected A function that will be\n *     invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!CancellablePromise} A new Promise that will receive the result of the\n *     callback.\n * @template THIS\n */\nCancellablePromise.prototype.thenCatch = function(onRejected, opt_context) {\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\n\n/**\n * Alias of {@link CancellablePromise.prototype.thenCatch}\n */\nCancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;\n\n\n/**\n * Cancels the Promise if it is still pending by rejecting it with a cancel\n * Error. No action is performed if the Promise is already resolved.\n *\n * All child Promises of the canceled Promise will be rejected with the same\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\n * is the only child of a pending Promise, the parent Promise will also be\n * canceled. Cancellation may propagate upward through multiple generations.\n *\n * @param {string=} opt_message An optional debugging message for describing the\n *     cancellation reason.\n */\nCancellablePromise.prototype.cancel = function(opt_message) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    async.run(function() {\n      var err = new CancellablePromise.CancellationError(opt_message);\n      err.IS_CANCELLATION_ERROR = true;\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\n\n\n/**\n * Cancels this Promise with the given error.\n *\n * @param {!Error} err The cancellation error.\n * @private\n */\nCancellablePromise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ === CancellablePromise.State_.PENDING) {\n    if (this.parent_) {\n      // Cancel the Promise and remove it from the parent's child list.\n      this.parent_.cancelChild_(this, err);\n    } else {\n      this.resolve_(CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Cancels a child Promise from the list of callback entries. If the Promise has\n * not already been resolved, reject it with a cancel error. If there are no\n * other children in the list of callback entries, propagate the cancellation\n * by canceling this Promise as well.\n *\n * @param {!CancellablePromise} childPromise The Promise to cancel.\n * @param {!Error} err The cancel error to use for rejecting the Promise.\n * @private\n */\nCancellablePromise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childIndex = -1;\n\n  // Find the callback entry for the childPromise, and count whether there are\n  // additional child Promises.\n  for (var i = 0, entry; (entry = this.callbackEntries_[i]); i++) {\n    var child = entry.child;\n    if (child) {\n      childCount++;\n      if (child === childPromise) {\n        childIndex = i;\n      }\n      if (childIndex >= 0 && childCount > 1) {\n        break;\n      }\n    }\n  }\n\n  // If the child Promise was the only child, cancel this Promise as well.\n  // Otherwise, reject only the child Promise with the cancel error.\n  if (childIndex >= 0) {\n    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {\n      this.cancelInternal_(err);\n    } else {\n      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];\n      this.executeCallback_(\n        callbackEntry, CancellablePromise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Adds a callback entry to the current Promise, and schedules callback\n * execution if the Promise has already been resolved.\n *\n * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing\n *     {@code onFulfilled} and {@code onRejected} callbacks to execute after\n *     the Promise is resolved.\n * @private\n */\nCancellablePromise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if ((!this.callbackEntries_ || !this.callbackEntries_.length) &&\n    (this.state_ === CancellablePromise.State_.FULFILLED ||\n    this.state_ === CancellablePromise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  if (!this.callbackEntries_) {\n    this.callbackEntries_ = [];\n  }\n  this.callbackEntries_.push(callbackEntry);\n};\n\n\n/**\n * Creates a child Promise and adds it to the callback entry list. The result of\n * the child Promise is determined by the state of the parent Promise and the\n * result of the {@code onFulfilled} or {@code onRejected} callbacks as\n * specified in the Promise resolution procedure.\n *\n * @see http://promisesaplus.com/#the__method\n *\n * @param {?function(this:THIS, TYPE):\n *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that\n *     will be invoked if the Promise is fullfilled, or null.\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\n *     invoked if the Promise is rejected, or null.\n * @param {THIS=} opt_context An optional execution context for the callbacks.\n *     in the default calling context.\n * @return {!CancellablePromise} The child Promise.\n * @template RESULT,THIS\n * @private\n */\nCancellablePromise.prototype.addChildPromise_ = function(\nonFulfilled, onRejected, opt_context) {\n\n  var callbackEntry = {\n    child: null,\n    onFulfilled: null,\n    onRejected: null\n  };\n\n  callbackEntry.child = new CancellablePromise(function(resolve, reject) {\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n\n    // Invoke onRejected, or reject with the parent's reason if absent.\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (!isDef(result) && reason.IS_CANCELLATION_ERROR) {\n          // Propagate cancellation to children if no other result is returned.\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(\n    /** @type {CancellablePromise.CallbackEntry_} */ (callbackEntry));\n  return callbackEntry.child;\n};\n\n\n/**\n * Unblocks the Promise and fulfills it with the given value.\n *\n * @param {TYPE} value\n * @private\n */\nCancellablePromise.prototype.unblockAndFulfill_ = function(value) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.FULFILLED, value);\n};\n\n\n/**\n * Unblocks the Promise and rejects it with the given rejection reason.\n *\n * @param {*} reason\n * @private\n */\nCancellablePromise.prototype.unblockAndReject_ = function(reason) {\n  if (this.state_ !== CancellablePromise.State_.BLOCKED) {\n    throw new Error('CancellablePromise is not blocked.');\n  }\n  this.state_ = CancellablePromise.State_.PENDING;\n  this.resolve_(CancellablePromise.State_.REJECTED, reason);\n};\n\n\n/**\n * Attempts to resolve a Promise with a given resolution state and value. This\n * is a no-op if the given Promise has already been resolved.\n *\n * If the given result is a Thenable (such as another Promise), the Promise will\n * be resolved with the same state and result as the Thenable once it is itself\n * resolved.\n *\n * If the given result is not a Thenable, the Promise will be fulfilled or\n * rejected with that result based on the given state.\n *\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\n *\n * @param {CancellablePromise.State_} state\n * @param {*} x The result to apply to the Promise.\n * @private\n */\nCancellablePromise.prototype.resolve_ = function(state, x) {\n  if (this.state_ !== CancellablePromise.State_.PENDING) {\n    return;\n  }\n\n  if (this === x) {\n    state = CancellablePromise.State_.REJECTED;\n    x = new TypeError('CancellablePromise cannot resolve to itself');\n\n  } else if (Thenable.isImplementedBy(x)) {\n    x = /** @type {!Thenable} */ (x);\n    this.state_ = CancellablePromise.State_.BLOCKED;\n    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);\n    return;\n\n  } else if (isObject(x)) {\n    try {\n      var then = x.then;\n      if (isFunction(then)) {\n        this.tryThen_(x, then);\n        return;\n      }\n    } catch (e) {\n      state = CancellablePromise.State_.REJECTED;\n      x = e;\n    }\n  }\n\n  this.result_ = x;\n  this.state_ = state;\n  this.scheduleCallbacks_();\n\n  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {\n    CancellablePromise.addUnhandledRejection_(this, x);\n  }\n};\n\n\n/**\n * Attempts to call the {@code then} method on an object in the hopes that it is\n * a Promise-compatible instance. This allows interoperation between different\n * Promise implementations, however a non-compliant object may cause a Promise\n * to hang indefinitely. If the {@code then} method throws an exception, the\n * dependent Promise will be rejected with the thrown value.\n *\n * @see http://promisesaplus.com/#point-70\n *\n * @param {Thenable} thenable An object with a {@code then} method that may be\n *     compatible with the Promise/A+ specification.\n * @param {!Function} then The {@code then} method of the Thenable object.\n * @private\n */\nCancellablePromise.prototype.tryThen_ = function(thenable, then) {\n  this.state_ = CancellablePromise.State_.BLOCKED;\n  var promise = this;\n  var called = false;\n\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      promise.unblockAndFulfill_(value);\n    }\n  };\n\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      promise.unblockAndReject_(reason);\n    }\n  };\n\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\n\n\n/**\n * Executes the pending callbacks of a resolved Promise after a timeout.\n *\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\n * callbacks must only be invoked from a call stack that only contains Promise\n * implementation code, which we accomplish by invoking callback execution after\n * a timeout. If {@code startExecution_} is called multiple times for the same\n * Promise, the callback chain will be evaluated only once. Additional callbacks\n * may be added during the evaluation phase, and will be executed in the same\n * event loop.\n *\n * All Promises added to the waiting list during the same browser event loop\n * will be executed in one batch to avoid using a separate timeout per Promise.\n *\n * @private\n */\nCancellablePromise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    async.run(this.executeCallbacks_, this);\n  }\n};\n\n\n/**\n * Executes all pending callbacks for this Promise.\n *\n * @private\n */\nCancellablePromise.prototype.executeCallbacks_ = function() {\n  while (this.callbackEntries_ && this.callbackEntries_.length) {\n    var entries = this.callbackEntries_;\n    this.callbackEntries_ = [];\n\n    for (var i = 0; i < entries.length; i++) {\n      this.executeCallback_(entries[i], this.state_, this.result_);\n    }\n  }\n  this.executing_ = false;\n};\n\n\n/**\n * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}\n * or {@code onRejected} callback based on the resolved state of the Promise.\n *\n * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the\n *     onFulfilled and/or onRejected callbacks for this step.\n * @param {CancellablePromise.State_} state The resolution status of the Promise,\n *     either FULFILLED or REJECTED.\n * @param {*} result The resolved result of the Promise.\n * @private\n */\nCancellablePromise.prototype.executeCallback_ = function(\ncallbackEntry, state, result) {\n  if (state === CancellablePromise.State_.FULFILLED) {\n    callbackEntry.onFulfilled(result);\n  } else {\n    this.removeUnhandledRejection_();\n    callbackEntry.onRejected(result);\n  }\n};\n\n\n/**\n * Marks this rejected Promise as having being handled. Also marks any parent\n * Promises in the rejected state as handled. The rejection handler will no\n * longer be invoked for this Promise (if it has not been called already).\n *\n * @private\n */\nCancellablePromise.prototype.removeUnhandledRejection_ = function() {\n  var p;\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n      p.hadUnhandledRejection_ = false;\n    }\n  }\n};\n\n\n/**\n * Marks this rejected Promise as unhandled. If no {@code onRejected} callback\n * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}\n * expires, the reason will be passed to the unhandled rejection handler. The\n * handler typically rethrows the rejection reason so that it becomes visible in\n * the developer console.\n *\n * @param {!CancellablePromise} promise The rejected Promise.\n * @param {*} reason The Promise rejection reason.\n * @private\n */\nCancellablePromise.addUnhandledRejection_ = function(promise, reason) {\n  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = setTimeout(function() {\n      CancellablePromise.handleRejection_.call(null, reason);\n    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);\n\n  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {\n    promise.hadUnhandledRejection_ = true;\n    async.run(function() {\n      if (promise.hadUnhandledRejection_) {\n        CancellablePromise.handleRejection_.call(null, reason);\n      }\n    });\n  }\n};\n\n\n/**\n * A method that is invoked with the rejection reasons for Promises that are\n * rejected but have no {@code onRejected} callbacks registered yet.\n * @type {function(*)}\n * @private\n */\nCancellablePromise.handleRejection_ = async.throwException;\n\n\n/**\n * Sets a handler that will be called with reasons from unhandled rejected\n * Promises. If the rejected Promise (or one of its descendants) has an\n * {@code onRejected} callback registered, the rejection will be considered\n * handled, and the rejection handler will not be called.\n *\n * By default, unhandled rejections are rethrown so that the error may be\n * captured by the developer console or a {@code window.onerror} handler.\n *\n * @param {function(*)} handler A function that will be called with reasons from\n *     rejected Promises. Defaults to {@code async.throwException}.\n */\nCancellablePromise.setUnhandledRejectionHandler = function(handler) {\n  CancellablePromise.handleRejection_ = handler;\n};\n\n\n\n/**\n * Error used as a rejection reason for canceled Promises.\n *\n * @param {string=} opt_message\n * @constructor\n * @extends {Error}\n * @final\n */\nCancellablePromise.CancellationError = class extends Error {\n  constructor(opt_message) {\n     super(opt_message);\n\n     if (opt_message) {\n       this.message = opt_message;\n     }\n   }\n};\n\n/** @override */\nCancellablePromise.CancellationError.prototype.name = 'cancel';\n\nexport {CancellablePromise};\nexport default CancellablePromise;\n"],"sourceRoot":"/source/"}